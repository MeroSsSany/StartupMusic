package dev.merosssany.musicaltune.core;

import static org.lwjgl.openal.AL10.*; // Static imports are fine
import static org.lwjgl.openal.ALC10.*; // Static imports for ALC10

import java.nio.ByteBuffer;
import java.nio.IntBuffer;

import org.lwjgl.openal.AL;
import org.lwjgl.openal.AL10;
import org.lwjgl.openal.ALC;
import org.lwjgl.openal.ALC10;
import org.lwjgl.system.MemoryUtil;

import dev.merosssany.musicaltune.init.OggLoader.AudioData;


//In your dev.merosssany.musicaltune.core package

public class AudioThread extends Thread {

	private volatile boolean running = true;
	private volatile boolean fadeOutRequested = false;
	private volatile float fadeDuration = 0;

	// OpenAL resources managed by THIS thread
	private long device = MemoryUtil.NULL;
	private long context = MemoryUtil.NULL;
	private int sourceId = 0; // This source ID will be generated by THIS thread
	private int bufferId = 0; // This buffer ID will be generated by THIS thread

	private AudioData audioData; // The audio data to play

    // --- Constructor ---
	public AudioThread(AudioData data) { // Pass only the AudioData needed for playback
		this.audioData = data;
		// sourceId and bufferId are NOT passed in; they are created by this thread
		this.setDaemon(true); // Make it a daemon thread
	}

	@Override
	public void run() {
		// --- OpenAL Initialization on THIS thread ---
		try {
			device = alcOpenDevice((ByteBuffer) null); // Use static import
			if (device == MemoryUtil.NULL) {
                System.err.println("AudioThread: Failed to open device");
				throw new IllegalStateException("Failed to open device");
            }

			context = alcCreateContext(device, (IntBuffer) null); // Use static import
			if (context == MemoryUtil.NULL) {
				alcCloseDevice(device); // Clean up device if context fails
                System.err.println("AudioThread: Failed to create context");
				throw new IllegalStateException("Failed to create context");
			}

			// Make context CURRENT on *this* thread
			alcMakeContextCurrent(context); // Use static import
			AL.createCapabilities(ALC.createCapabilities(device)); // Initialize capabilities for this context

			System.out.println("AudioThread: OpenAL initialized and context current.");

			// --- Resource Generation and Playback Setup on THIS thread ---
            // Generate source and buffer here
			bufferId = alGenBuffers(); // Use static import
			sourceId = alGenSources(); // Use static import

            // Check for errors after generation
            int error = AL10.alGetError();
            if (error != AL_NO_ERROR) {
                 System.err.println("AudioThread: Error generating source/buffer: " + AL10.alGetString(error));
                 // Clean up if generation fails
                 if (bufferId != 0) alDeleteBuffers(bufferId);
                 if (sourceId != 0) alDeleteSources(sourceId);
                 sourceId = 0; bufferId = 0; // Reset IDs
                 running = false; // Stop the thread if setup fails
            }


            if (running && sourceId != 0) { // Proceed only if generation was successful
                int format; // Determine format based on audio data channels
                if (audioData.channels == 1) {
                    format = AL_FORMAT_MONO16; // Use static import
                } else if (audioData.channels == 2) {
                    format = AL_FORMAT_STEREO16; // Use static import
                } else {
                    System.err.println("AudioThread: Unsupported audio channels: " + audioData.channels);
                     alDeleteSources(sourceId); alDeleteBuffers(bufferId); sourceId = 0; bufferId = 0; // Cleanup
                    running = false; // Stop the thread
                    throw new IllegalStateException("Only mono or stereo is supported");
                }

                // Buffer data and play
                alBufferData(bufferId, format, audioData.samples, audioData.sampleRate); // Use static import
                error = AL10.alGetError();
                 if (error != AL_NO_ERROR) {
                    System.err.println("AudioThread: Error buffering data: " + AL10.alGetString(error));
                     alDeleteSources(sourceId); alDeleteBuffers(bufferId); sourceId = 0; bufferId = 0; // Cleanup
                    running = false; // Stop the thread
                 }

                 if (running && sourceId != 0) {
                    alSourcei(sourceId, AL_BUFFER, bufferId); // Attach buffer to source (Use static import)
                    alSourcePlay(sourceId); // Start playback (Use static import)
                    error = AL10.alGetError();
                     if (error != AL_NO_ERROR) {
                        System.err.println("AudioThread: Error starting playback: " + AL10.alGetString(error));
                         alDeleteSources(sourceId); alDeleteBuffers(bufferId); sourceId = 0; bufferId = 0; // Cleanup
                        running = false; // Stop the thread
                     } else {
                         System.out.println("AudioThread: Started playing source: " + sourceId);
                     }
                 }
            }


			// --- Main Thread Loop ---
			while (running) {
				if (fadeOutRequested) {
                    // Check if source is still valid before fading
                    if (sourceId != 0) {
					    performFadeOut(fadeDuration);
                    } else {
                         System.out.println("AudioThread: Fade requested but source is invalid.");
                    }
					fadeOutRequested = false; // Reset flag after performing fade
				}

				// Sleep briefly to avoid busy-waiting.
                // This thread's purpose is to manage playback and respond to requests.
                // If using the time-based updateFade logic, this sleep might be adjusted
                // or managed differently to allow consistent time updates.
				try {
					Thread.sleep(10); // Sleep for 10 milliseconds (100 times per second)
				} catch (InterruptedException e) {
					Thread.currentThread().interrupt(); // Restore interrupt status
					running = false; // Exit loop on interrupt
				}
			}

		} catch (Exception e) {
			System.err.println("AudioThread Error: " + e.getMessage());
			e.printStackTrace();
		} finally {
			// --- OpenAL Cleanup on THIS thread ---
            System.out.println("AudioThread: Cleaning up OpenAL.");
			// Un-context this thread
			ALC10.alcMakeContextCurrent(MemoryUtil.NULL); // Use static import

			// Destroy Context and Close Device (Check for NULL pointers)
			if (context != MemoryUtil.NULL) ALC10.alcDestroyContext(context); // Use static import
			if (device != MemoryUtil.NULL) ALC10.alcCloseDevice(device); // Use static import

            // Delete Source and Buffer (Check for valid IDs)
            if (sourceId != 0) alDeleteSources(sourceId); // Use static import
            if (bufferId != 0) alDeleteBuffers(bufferId); // Use static import

            // Reset pointers/IDs
            device = MemoryUtil.NULL;
            context = MemoryUtil.NULL;
            sourceId = 0;
            bufferId = 0;

            System.out.println("AudioThread: OpenAL cleanup complete.");
		}
	}

	// Method called by another class (like AudioPlayer or EventHandler) to request a fade
	public void requestFadeOut(float duration) {
		if (running && sourceId != 0 && !fadeOutRequested) { // Only request if running, source valid, and not already requested
			this.fadeDuration = duration;
			this.fadeOutRequested = true; // Signal the thread
            System.out.println("AudioThread: Fade out requested.");
		} else {
             System.out.println("AudioThread: Fade out request ignored (running: " + running + ", sourceId: " + sourceId + ", requested: " + fadeOutRequested + ")");
        }
	}
	
	private void performFadeOut(float durationSeconds) {
		if (sourceId == 0) return; // Cannot fade if no source

		System.out.println("AudioThread: Performing fade out logic.");
		float initialGain = AL10.alGetSourcef(sourceId, AL10.AL_GAIN);
		int steps = 20; // Number of steps in the fade
		float sleepTime = durationSeconds / steps; // Time to sleep between steps

		for (int i = steps; i >= 0; i--) {
			if (!running) break; // Allow thread to stop during fade loop
			float gain = initialGain * ((float) i / steps);
			AL10.alSourcef(sourceId, AL10.AL_GAIN, gain);
			try {
				Thread.sleep((long) (sleepTime * 1000)); // BLOCKING CALL on THIS thread
			} catch (InterruptedException e) {
				Thread.currentThread().interrupt();
				running = false; // Stop the thread on interrupt
				break;
			}
		}
		if (running) { // Only stop the source if the thread is still running (not interrupted)
			AL10.alSourceStop(sourceId);
			System.out.println("AudioThread: Fade out complete. Source stopped.");
              if (sourceId != 0) alDeleteSources(sourceId); sourceId = 0;
              if (bufferId != 0) alDeleteBuffers(bufferId); bufferId = 0;
		} else {
            System.out.println("AudioThread: Fade out interrupted.");
        }
	}

    // Method to stop the thread gracefully
    public void shutdown() {
        System.out.println("AudioThread: Shutdown requested.");
        running = false; // Signal the loop to stop
        this.interrupt(); // Interrupt any sleep/wait
        // You might want to add a timeout and join() here in the caller
    }
}